


int convolution(pgm* image, int kernel[3][3], int row, int col) { // a imagem vai ser mesmo a imagem tipo duh 
// o kernel vai ser a matrix do sobel (horizontal ou vertical)   // posição

	int i, j, sum = 0; 
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			sum += image->imageData[i + row][j + col] * kernel[i][j]; 
			
			// a soma propriamente dita. aqui temos 2 for's para somar todos os elementos 
		}
	}
	return sum;
}









o convolution vai devolver um unico valor a partir de uma soma 

void sobel_edge_detector(pgm* image, pgm* out_image) {
	int i, j, gx, gy;
	int mx[3][3] = {
		{-1, 0, 1},
		{-2, 0, 2},
		{-1, 0, 1}
	};
	int my[3][3] = {
		{-1, -2, -1},
		{0, 0, 0},
		{1, 2, 1}
	};
	
	for (i = 1; i < image->height - 2; i++) {
		for (j = 1; j < image->width - 2; j++) {
			gx = convolution(image, mx, i, j);
			gy = convolution(image, my, i, j);
			out_image->imageData[i][j] = sqrt(gx*gx + gy*gy);
			out_image->gx[i][j] = gx;
			out_image->gy[i][j] = gy;
		}
	}
	
}
